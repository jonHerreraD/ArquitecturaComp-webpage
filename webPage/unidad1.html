<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unidad 1</title>
    <link rel="stylesheet" href="styleUnidad1.css">
</head>
<body>
    <div class="header">
        <div class="title"><h1>ARQUITECTURA DE COMPUTADORAS</h1></div>
    </div>

    <section class="menu-bar">
        <nav class="flex-container">
            <div class="con2">
                    <div id="inicio">
                        <ul>
                            <li><a href="index.html">inicio</a></li>
                        </ul>
                    </div>
                    <div class="list">
                        <ul>
                            <li><a href="unidad2.html">Unidad 2</a></li>
                            <li><a href="unidad3.html">Unidad 3</a></li>
                            <li><a href="unidad4.html">Unidad 4</a></li>
                            <li><a href="">Practicas</a></li>
                        </ul>
                    </div>
            </div>
        </nav>
    </section>
    <section class="two">
        <section class="side-bar">
            <nav class="side-container">
                <div class="side-content">
                    <a href="">1.1 Modelos de Arquitectura de Computo</a>
                    <ul>
                        <li><a href="">1.1.1 Clasicas</a></li>
                        <li><a href="">1.1.2 Segmentadas</a></li>
                        <li><a href="">1.1.3 Multiprocesamiento</a></li>
                    </ul>
                    <a href="">1.2 Analisis de Componentes</a>
                    <ul>
                        <a href="">1.2.1 Arquitecturas</a>
                        <ul>
                            <li><a href="">1.2.1.1 CPU</a></li>
                            <li><a href="">1.2.1.2 ALU</a></li>
                            <li><a href="">1.2.1.3 Registros</a></li>
                            <li><a href="">1.2.1.4 Buses</a></li>
                        </ul>
                        <a href="">1.2.2 Memoria</a>
                        <ul>
                            <li><a href="">1.2.2.1 Manejo de memoria</a></li>
                            <li><a href="">1.2.2.2 Memoria principal</a></li>
                            <li><a href="">1.2.2.3 Memoria Cache</a></li>
                        </ul>
                        <a href="">1.2.3 Manejo de Entrada/Salida</a>
                        <ul>
                            <li><a href="">1.2.3.1 Modulo E/S</a></li>
                            <li><a href="">1.2.3.2 E/S programada</a></li>
                            <li><a href="">1.2.3.3 E/S mediante interrupciones</a></li>
                            <li><a href="">1.2.3.4 Acceso directo a memoria</a></li>
                            <li><a href="">1.2.3.5 Canales de E/S</a></li>
                        </ul>
                        <a href="">1.2.4 Buses</a>
                        <ul>
                            <li><a href="">1.2.4.1 Tipos de buses</a></li>
                            <li><a href="">1.2.4.2 Estructura de los buses</a></li>
                            <li><a href="">1.2.4.3 Jerarquia de los buses</a></li>
                        </ul>
                        <a href="">1.2.5 Interrupciones</a>
                    </ul>
                </div>
            </nav>
        </section>
        <section class="info">
            <div class="info-container">
                <div class="info-content">
                    <h2>1.1 Modelos de Arquitectura de Cómputo</h2>
        <p>La arquitectura de computadoras es el diseño y la organización de un sistema para un equipo de cómputo. Es un modelo y descripción de cada función, así como los requerimientos y las implementaciones de diseño para varias partes del equipo de cómputo.</p>
        
        <section>
            <h3>1.1.1 Clásicas</h3>
            <p>Estas arquitecturas se desarrollaron en las primeras computadoras electromecánicas y de tubos de vacío.</p>
            
            <article>
                <h4>Arquitectura Von Neumann</h4>
                <p>La unidad central de proceso (CPU), está conectada a una memoria principal única (casi siempre sólo RAM) donde se guardan las instrucciones del programa y los datos. A dicha memoria se accede a través de un sistema interconexión de buses único (control, direcciones y datos).</p>
                <p>En un sistema con arquitectura Von Neumann el tamaño de la unidad de datos o instrucciones está fijado por el ancho del bus que comunica la memoria con la CPU.El tener un único bus hace que el microprocesador sea más lento en su respuesta, ya que no puede buscar en memoria una nueva instrucción mientras no finalicen las transferencias de datos de la instrucción anterior.</p>
                <p>
                    Componentes principales de Von Neumann: Unidad de Memoria. Unidad de Entrada/Salida. Unidad de Control. Incluidos CPU. Unidad Aritmética Lógica. Incluida en CPU. Registros de Programas. Incluidos en CPU.Las instrucciones provenientes del sistema de entrada, son almacenados por la memoria, procesados por la ALU bajo la dirección de la unidad de control. Los resultados obtenidos son enviados a la unidad de salida. En las computadoras de programa almacenado, el programa puede manipularse como si se tratara de datos. Este concepto da origen a los compiladores, sistemas operativos y es la base de la gran versatilidad de las computadoras modernas.
                </p>
                <p>
                    Limitaciones del modelo Von Neumann: La longitud de las instrucciones por el bus de datos, que hace que el microprocesador tenga que realizar varios accesos a memoria para buscar instrucciones complejas.
                </p>
                <!-- ... (continuar con el contenido) -->
            </article>
            
            <article>
                <h4>Modelo Harvard</h4>
                <p>Esta arquitectura utiliza los Micro controladores, tiene la unidad central de proceso (CPU) conectada a dos memorias (una con las instrucciones y otra con los datos) por medio de dos buses diferentes.</p>
                <p>Una de las memorias contiene solamente las instrucciones del programa (Memoria de Programa), y la otra sólo almacena datos (Memoria de Datos).Ambos buses son totalmente independientes lo que permite que la CPU pueda acceder de forma independiente y simultánea a la memoria de datos y a la de instrucciones. El tamaño de las instrucciones no está relacionado con el de los datos, y por lo tanto puede ser optimizado para que cualquier instrucción ocupe una sola posición de memoria de programa, logrando así mayor velocidad y menor longitud de programa.</p>
                <p>
                    La principal desventaja de esta arquitectura; el bus de datos y direcciones único se convierte en un cuello de botella por el cual debe pasar toda la información que se lee de o se escribe a la memoria, obligando a que todos los accesos a esta sean secuenciales. Limita el grado de paralelismo (acciones que se pueden realizar al mismo tiempo) y por lo tanto, el desempeño de la computadora.
                </p>
                <!-- ... (continuar con el contenido) -->
            </article>
        </section>
        
        <section>
            <h3>1.1.2 Segmentadas</h3>
            <p>Es una de las tecnologías utilizadas para realizar la segmentación o paralelismo. Divide el procesador, en etapas, procesa una instrucción diferente en cada una y trabaja con varias a la vez.</p>
            <p>Pueden trabajar de forma paralela, en diferentes instrucciones, utilizando una cola de instrucciones para su comunicación, denominado entubamiento.La técnica de implementación clave utilizada para hacer CPU.</p>
            <p>
                La dependencia de datos y de control, que tiene como efecto la disminución del rendimiento del pipelining.

                La segmentación de cauce (pipelining) es una forma efectiva de organizar el hardware del CPU para realizar más de una operación al mismo tiempo. Consiste en descomponer el proceso de ejecución de las instrucciones en fases o etapas que permitan una ejecución simultánea.
            </p>
            <p>
                Las etapas están conectadas, cada una a la siguiente, para formar una especie de cauce las instrucciones se entran por un extremo, son procesadas a través de las etapas y salen por el otro. La productividad de la segmentación está determinada por la frecuencia con que una instrucción salga del cauce.
            </p>
            <!-- ... (continuar con el contenido) -->
        </section>
        
        <section>
            <h3>1.1.3 Multiprocesamiento</h3>
            <p>Se denomina multiprocesador a un computador que cuenta con dos o más microprocesadores (CPUs).</p>
            <p>La arquitectura NUMA, donde cada procesador tiene acceso y control exclusivo a una parte de la memoria.</p>
            <img src="../img/multiprocesamiento.jpg" alt="">
            <p>
                Para que un multiprocesador opere correctamente necesita un sistema operativo especialmente diseñado para ello.

                La arquitectura NUMA, donde cada procesador tiene acceso y control exclusivo a una parte de la memoria. La arquitectura SMP, donde todos los procesadores comparten toda la memoria.
            </p>
            <p>
                Los CPU de multiprocesamiento según Flynn se clasifican de la siguiente manera:
                <ul class="rojo">
                    <li>SISO : (Single Instruction, Single Operand) computadoras. Monoprocesador</li>
                    <li>SIMO : (Single Instruction, Multiple Operand) procesadores vectoriales, Exenciones MMX</li>
                    <li>MISO : (Multiple Instruction, Single Operand) No implementado</li>
                    <li>MIMO : (Multiple Instruction, Multiple Operand) sistemas SMP, Clusters, GPUs</li>
                </ul> 
            </p>
            <p>
                Los procesadores vectoriales, son computadoras pensadas para aplicar un mismo algoritmo numérico a una serie de datos matriciales, en especial en la simulación de sistemas físicos complejos, tales como simuladores de clima, explosiones atómicas, reacciones químicas, etc. Donde los datos son representados como grandes números de datos en forma matricial sobre los que se deben se aplicar el mismo algoritmo numérico.

                Los Procesadores Digitales de Señales (DSP), son procesadores especializados en el procesamiento de señales tales como audio, vídeo, radar, sonar, radio, etc. Cuentan con instrucciones tipo vectorial que los hace muy aptos para dicha aplicación.
            </p>
            <!-- ... (continuar con el contenido) -->
            <article>
                <h4>SMP</h4>
                <p>En los sistemas SMP (Simetric Multiprocessing), varios procesadores comparten la misma memoria principal y periféricos de Entrada /Salida, normalmente conectados por un bus común.</p>
                <p>Se conocen como simétricos, ya que ningún procesador toma el papel de maestro y los demás de esclavos, sino que todos tienen derechos similares en cuanto al acceso a la memoria y periféricos y ambos son administrados por el sistema operativo. Pueden formarse con varios núcleos en un solo circuito integrado o con varios circuitos integrados en una misma tarjeta madre. La primera opción ha sido popularizada al hacerse más económicos los procesadores multinúcleo de los principales fabricantes y con su uso en sistemas de gama media y baja, e inclusive en teléfonos celulares y tabletas.</p>
                <p>La segunda opción fue la que se uso en un principio y sigue siendo usada en en estaciones de trabajo y en servidores de alto rendimiento debido a que incrementa el poder computacional del sistema, pero también incrementa considerablemente el costo del sistema.</p>
            </article>
            <article>
                <h4>Clusters</h4>
                <p>Conjuntos de computadoras independientes conectadas en una red de área local o por un bus de interconexión y que trabajan cooperativamente. Con un sistema de procesamiento paralelo o distribuido.</p>
                <p>Es clave en su funcionamiento contar con un sistema operativo y programas de aplicación capaces de distribuir el trabajo entre las computadoras de la red.
                </p>
                <p>Se debe tener cuidado al implementar la aplicación, ya que si los datos que hay que pasar de un procesador a otro son demasiados, el tiempo empleado en pasar información de un nodo a otro puede sobrepasar a la ganancia que se tiene al dividir el trabajo entre varios procesadores.
                </p>
            </article>
        </section>
        <h2>1.2 Análisis de Componentes</h2>
        <p>
            Los programas cada vez más grandes y complejos demandan mayor velocidad en el procesamiento de información, lo que implica la elección de microprocesadores más rápidos y eficientes.
        </p>
        <section>
            <h3>1.2.1 Arquitecturas</h3>
            <article>
                <h4>Arquitecturas Cisc</h4>
                <p>En la arquitectura computacional, CISC es un modelo de arquitectura, en donde los microprocesadores tienen un conjunto instrucciones que caracterizan por ser muy amplio y permitir operaciones complejas entre operandos, situados en la memoria o en los registros internos.</p>
                <p>Este tipo de arquitectura dificulta el paralelismo entre instrucciones, por lo que, en la actualidad, la mayoría de los sistemas CISC de alto rendimiento implementan un sistema que convierte dichas instrucciones complejas en varias instrucciones simples del tipo RISC, llamadas generalmente microinstrucciones.</p>
                <p>Dato importante: Los CISC pertenecen a la primera corriente de construcción de procesadores, antes del desarrollo de los RISC. Ademas Para realizar una sola instrucción un chip CISC requiere de cuatro a diez ciclos de reloj.</p>
                <p>Entre las ventajas de CISC destacan las siguientes:
                    <ul class="rojo">
                        <li>Reduce la dificultad de crear compiladores.</li>
                        <li>Permite reducir el costo total del sistema.</li>
                        <li>Reduce los costos de creación de software.</li>
                        <li>Mejora la compactación de código.</li>
                        <li>Facilita la depuración de errores.</li>
                    </ul>
                </p>
            </article>
        </section>
         </div>
        </div>
        </section>
    </section>
</body>
</html>